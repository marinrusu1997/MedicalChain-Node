"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const path = __importStar(require("path"));
const errors_1 = require("./errors");
const Migration_1 = require("./Migration");
class MigrationRunner {
    constructor(pgp, migrations, schemaName = 'public', skipSetup = false) {
        this.pgp = pgp;
        this.migrations = migrations;
        this.schemaName = schemaName;
        this.isSetUp = false;
        const migrationNames = migrations.map((f) => f.name);
        const nameDups = this.findDups(migrationNames);
        if (nameDups.length > 0) {
            throw new errors_1.NonUniqueMigrationNameError(nameDups);
        }
        if (skipSetup) {
            this.isSetUp = true;
        }
    }
    setup() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.checkOrCreateSchema();
            yield this.checkOrCreateTables();
            yield this.installCyanAudit();
            this.isSetUp = true;
        });
    }
    migrate(sequenceName = 'default', blockNumber = 0, pgp = this.pgp, initial = false) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.throwIfNotSetup();
            const unapplied = yield this.getUnappliedMigrations(initial);
            for (const migration of unapplied) {
                yield this.applyMigration(pgp, migration, sequenceName, blockNumber);
            }
        });
    }
    applyMigration(pgp, migration, sequenceName, blockNumber) {
        return __awaiter(this, void 0, void 0, function* () {
            yield migration.up(pgp);
            yield this.refreshCyanAudit();
            yield this.registerMigration(pgp, migration.name, sequenceName, blockNumber);
        });
    }
    // public async revertTo(migrationName) {} // Down migrations
    checkOrCreateTables() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.pgp.none(`
      CREATE TABLE IF NOT EXISTS $1:raw._migration(
        id           serial  PRIMARY KEY,
        name         text,
        sequence     text,
        block_number integer
      );
    `, [this.schemaName]);
            yield this.pgp.none(`
      CREATE TABLE IF NOT EXISTS $1:raw._index_state (
        id                   serial  PRIMARY KEY,
        block_number         integer NOT NULL,
        block_hash           text    NOT NULL,
        is_replay            boolean NOT NULL,
        handler_version_name text    DEFAULT 'v1'
      );
    `, [this.schemaName]);
            yield this.pgp.none(`
      CREATE TABLE IF NOT EXISTS $1:raw._block_number_txid (
        block_number integer PRIMARY KEY,
        txid         bigint  NOT NULL
      );
    `, [this.schemaName]);
        });
    }
    checkOrCreateSchema() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.pgp.none(`
      CREATE SCHEMA IF NOT EXISTS $1:raw;
    `, [this.schemaName]);
        });
    }
    installCyanAudit() {
        return __awaiter(this, void 0, void 0, function* () {
            const cyanaudit = new Migration_1.Migration('', '', path.join(__dirname, 'cyanaudit/cyanaudit--2.2.0.sql'));
            yield cyanaudit.up(this.pgp);
            yield this.refreshCyanAudit();
        });
    }
    refreshCyanAudit(pgp = this.pgp) {
        return __awaiter(this, void 0, void 0, function* () {
            yield pgp.many('SELECT cyanaudit.fn_update_audit_fields($1)', [this.schemaName]);
        });
    }
    registerMigration(pgp, migrationName, sequenceName, blockNumber) {
        return __awaiter(this, void 0, void 0, function* () {
            yield pgp.none(`
      INSERT INTO $1:raw._migration (name, sequence, block_number) VALUES ($2, $3, $4);
    `, [this.schemaName, migrationName, sequenceName, blockNumber]);
        });
    }
    getUnappliedMigrations(initial = false) {
        return __awaiter(this, void 0, void 0, function* () {
            const migrationHistory = yield this.getMigrationHistory();
            yield this.validateMigrationHistory(migrationHistory, initial);
            return this.migrations.slice(migrationHistory.length);
        });
    }
    getMigrationHistory() {
        return __awaiter(this, void 0, void 0, function* () {
            const migrationRows = yield this.pgp.manyOrNone(`
      SELECT name FROM $1:raw._migration;
    `, [this.schemaName]);
            return migrationRows.map((row) => row.name);
        });
    }
    validateMigrationHistory(migrationHistory, initial = false) {
        // Make sure that the migrations in this.migrations match to the migration history
        for (let i = 0; i < migrationHistory.length; i++) {
            if (i === migrationHistory.length && initial) {
                break;
            }
            else if (i === migrationHistory.length) {
                throw new errors_1.ExtraMigrationHistoryError();
            }
            if (migrationHistory[i] !== this.migrations[i].name) {
                throw new errors_1.MismatchedMigrationsHistoryError();
            }
        }
    }
    throwIfNotSetup() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.isSetUp) {
                yield this.checkSchema(this.schemaName);
                yield this.checkTable('_migration');
                yield this.checkTable('_index_state');
                yield this.checkTable('_block_number_txid');
                yield this.checkSchema('cyanaudit');
                this.isSetUp = true;
            }
        });
    }
    checkSchema(schema) {
        return __awaiter(this, void 0, void 0, function* () {
            const { exists } = yield this.pgp.one(`
      SELECT EXISTS(SELECT 1 FROM pg_namespace WHERE nspname = $1);
      `, [schema]);
            if (!exists) {
                throw new errors_1.MissingSchemaError(schema);
            }
        });
    }
    checkTable(table) {
        return __awaiter(this, void 0, void 0, function* () {
            const { exists } = yield this.pgp.one(`
      SELECT EXISTS (
        SELECT 1
        FROM   information_schema.tables
        WHERE  table_schema = $1
        AND    table_name = $2
      );
      `, [this.schemaName, table]);
            if (!exists) {
                throw new errors_1.MissingTableError(table);
            }
        });
    }
    findDups(arr) {
        return arr.reduce((acc, el, i) => {
            if (arr.indexOf(el) !== i && acc.indexOf(el) < 0) {
                acc.push(el);
            }
            return acc;
        }, []);
    }
}
exports.MigrationRunner = MigrationRunner;
